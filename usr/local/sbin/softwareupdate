#!/bin/bash
# softwareupdate - Actualiza paquetes instalados mediante aptitude o apt-get, flatpak, snap y realiza limpieza
# 2013-2025 Esteban M. Navas Martín <algodelinux@gmail.com>.
#

export VERSION=1.19

# Usar preferentemente apt-get y, si no se encuentra instalado, usar aptitude
APT_COMMAND=$(command -v apt-get)
#[ -z "$APT_COMMAND" ] && APT_COMMAND=$(command -v aptitude)

APT_ARGS="--yes --quiet --allow-downgrades --allow-change-held-packages --fix-missing \
        --fix-broken --auto-remove --allow-unauthenticated \
        --show-upgraded \
        --option Dpkg::Options::=--force-confdef --option Dpkg::Options::=--force-confold"

convert_seconds() {
    local SEGUNDOS=$1

    # Validar que el parámetro sea un número positivo
    if ! [[ $SEGUNDOS =~ ^[0-9]+$ ]]; then
        echo "Error: El parámetro debe ser un número entero positivo."
        return 1
    fi

    # Calcular los valores
    local DIAS=$(( SEGUNDOS / 86400 ))
    local HORAS=$(( (SEGUNDOS % 86400) / 3600 ))
    local MINUTOS=$(( (SEGUNDOS % 3600) / 60 ))
    local SEGUNDOS_RESTANTES=$(( SEGUNDOS % 60 ))

    # Construir el resultado dinámicamente
    local RESULTADO=""
    [ $DIAS -gt 0 ] && RESULTADO="$RESULTADO$DIAS días, "
    [ $HORAS -gt 0 ] && RESULTADO="$RESULTADO$HORAS horas, "
    [ $MINUTOS -gt 0 ] && RESULTADO="$RESULTADO$MINUTOS minutos, "
    [ $SEGUNDOS_RESTANTES -gt 0 ] && RESULTADO="$RESULTADO$SEGUNDOS_RESTANTES segundos, "

    # Eliminar la última coma y espacio
    RESULTADO=${RESULTADO%, }

    echo "$RESULTADO"
}

print_help() {
        echo "$(basename $0) $VERSION"
        echo "Actualizar el software del equipo"
        echo ""
        echo "Uso: $0 [OPTIONS]"
        echo "Opciones reconocidas:"
        echo "  -h               mostrar esta ayuda y salir."
        echo "  -S               apagar el equipo al finalizar el proceso de actualización."
        echo "  -R               reiniciar el equipo al finalizar el proceso de actualización."
        echo ""
}

killprocess() {

   updatehour=$(ps aux|grep $1 | grep -v grep | head -1 | awk '{print $9}')
   if [ -n $updatehour ]; then
      timestampupdate=$(date -d "$updatehour" +'%s')
      timestampnow=$(date +'%s')
      diference=$(($timestampnow - $timestampupdate))
      minutesfromupdate=$(($diference / 60))

      if [[ $minutesfromupdate -gt $2 ]]; then
         # Matamos proceso
         pkill -9 $1 2>/dev/null
      fi
   fi
}

disable_failed_repositories () {
  # Deshabilitamos los repositorios que fallan de /etc/apt/sources.list.d
  if [ -s /tmp/failedrepositories ]; then
     while read repository; do
       failedfilerepository=$(find /etc/apt/sources.list.d/ -iname "*.list" -exec grep -H "$repository" {} \; | cut -f1 -d":")
       mv $failedfilerepository $failedfilerepository.disabled
     done </tmp/failedrepositories
  fi
}

enable_repositories () {
  # Habilitamos los repositorios deshabilitados en /etc/apt/sources.list.d
  for file in $(find /etc/apt/sources.list.d/ -iname "*.disabled"); do
    [ -f $file ] && mv -f "$file" "${file%%.disabled}"
  done
}

wait_while_locked () {
   [ -x /usr/local/sbin/wait_for_apt_or_dpkg ] && timeout $TIMEOUT_FOR_DPKG_OR_APT /usr/local/sbin/wait_for_apt_or_dpkg
}

run_aptitude() {

  # Detectar si aptitude está disponible, de lo contrario usar apt-get
  if command -v aptitude >/dev/null 2>&1; then
      APT_COMMAND="aptitude"
      SANITIZED_ARGS="$APTITUDE_ARGS"
  else
      APT_COMMAND="apt-get"

      # Filtro de opciones incompatibles con apt-get
      SANITIZED_ARGS=$(echo "$APTITUDE_ARGS" | sed -E '
         s/--without-recommends//g;
         s/--with-recommends//g;
         s/--verbose//g;
         s/--quiet=[0-9]+//g;
         s/--display-format=[^ ]+//g;
      ' | tr -s ' ')
  fi

  BASE_CMD="$APT_COMMAND $SANITIZED_ARGS"

  if [[ $@ == *full-upgrade* ]]; then
     :> /var/log/pkgsync/removefromlists.log
     COMMAND="$BASE_CMD $@"

     retry=1
     while [ $retry -eq 1 ]; do
         echo "RUNNING: $COMMAND"
         wait_while_locked; LC_ALL=C $COMMAND | tee /tmp/apterrors

         problematic_package=$(grep 'Couldn'\''t find any package' /tmp/apterrors | cut -d'"' -f2)

         if [ -n "$problematic_package" ]; then
            echo -e "Package $problematic_package isn't in repositories" \
                | tee -a /var/log/pkgsync/removefromlists.log

            COMMAND=$(echo "$COMMAND" \
                | sed "s/${problematic_package}[^[:space:]]*//" \
                | tr -s ' ')
         else
            retry=0
         fi
     done
  else
     echo "RUNNING: $BASE_CMD $*"
     wait_while_locked; $BASE_CMD "$@"
  fi

  return $?
}


check_apt_update() {
    # Colores para mensajes
    GREEN='\033[0;32m'
    NC='\033[0m'

    # Umbral en segundos (por defecto 1 día)
    local THRESHOLD_FOR_APT_UPDATE=${THRESHOLD_FOR_APT_UPDATE:-86400}

    # Archivos de caché de apt
    local PKG_CACHE="/var/cache/apt/pkgcache.bin"
    local SRC_CACHE="/var/cache/apt/srcpkgcache.bin"

    # Comprobar cuál existe y tomar el más reciente
    local LATEST_CACHE=""
    if [ -f "$PKG_CACHE" ] && [ -f "$SRC_CACHE" ]; then
        if [ "$PKG_CACHE" -nt "$SRC_CACHE" ]; then
            LATEST_CACHE="$PKG_CACHE"
        else
            LATEST_CACHE="$SRC_CACHE"
        fi
    elif [ -f "$PKG_CACHE" ]; then
        LATEST_CACHE="$PKG_CACHE"
    elif [ -f "$SRC_CACHE" ]; then
        LATEST_CACHE="$SRC_CACHE"
    else
        echo -e "${GREEN}No se encontraron archivos de caché de apt. Ejecutando 'apt update'...${NC}"
        sudo apt update
        return
    fi

    # Calcular antigüedad
    local LAST_UPDATE=$(stat -c %Y "$LATEST_CACHE")
    local CURRENT_TIME=$(date +%s)
    local AGE=$((CURRENT_TIME - LAST_UPDATE))

    # Convertir AGE en días, horas, minutos
    local DAYS=$((AGE / 86400))
    local HOURS=$(((AGE % 86400) / 3600))
    local MINUTES=$(((AGE % 3600) / 60))
    local AGE_HUMAN="${DAYS}d ${HOURS}h ${MINUTES}m"

    # Decidir si ejecutar apt update
    if [ "$AGE" -gt "$THRESHOLD_FOR_APT_UPDATE" ]; then
        echo -e "${GREEN}Han pasado ${AGE_HUMAN} desde la última actualización. Ejecutando 'apt update'...${NC}"
        sudo apt update 2>&1 | grep '^Err:' | grep -Eo "(http|https)://[a-zA-Z0-9./?=_%-]*" > /tmp/failedrepositories
    else
        echo -e "${GREEN}No es necesario ejecutar 'apt update'. Última ejecución hace ${AGE_HUMAN}.${NC}"
    fi
}

unlock_dpkg() {
    local TIME_MINUTES="${1:-5}"
    local LOG_FILE="/var/log/solve-apt-errors.log"

    # For testing purposes only
    # echo -e "${CYAN}Buscando procesos dpkg/apt bloqueados o configurando paquetes desde más de $TIME_MINUTES minutos...${NC}" | tee -a "$LOG_FILE"

    ps -eo pid,etime,comm,args --sort=etime | while read -r PID ETIME COMM ARGS; do
        # Solo dpkg o apt
        if [[ "$COMM" != "dpkg" && "$COMM" != "apt" ]]; then
            continue
        fi

        # Convertir ETIME a minutos aproximados
        minutes=0
        if [[ $ETIME =~ - ]]; then
            # D-HH:MM o D-HH:MM:SS
            IFS=- read -r DAYS TIME_PART <<< "$ETIME"
            IFS=: read -r H M S <<< "$TIME_PART:0:0"
            minutes=$((DAYS*24*60 + H*60 + M))
        else
            # HH:MM:SS o MM:SS
            IFS=: read -r H M S <<< "$ETIME:0:0"
            H=${H:-0}
            M=${M:-0}
            minutes=$((H*60 + M))
        fi

        if [ "$minutes" -ge "$TIME_MINUTES" ]; then
            # Identificar si está configurando un paquete
            ACTION_DESC="bloqueado"
            [[ "$ARGS" == *"--configure"* ]] && ACTION_DESC="configurando paquetes"

            echo -e "${RED}Proceso $PID ($COMM) $ACTION_DESC lleva $minutes minutos. Terminando...${NC}" | tee -a "$LOG_FILE"

            kill -TERM "$PID" 2>/dev/null
            sleep 2
            if ps -p "$PID" > /dev/null; then
                echo -e "${RED}Proceso $PID no terminó, forzando KILL...${NC}" | tee -a "$LOG_FILE"
                kill -KILL "$PID" 2>/dev/null
            fi
        fi
    done

}

reinstall_broken_dpkg() {
    local INFO_DIR="/var/lib/dpkg/info"
    local BROKEN_PACKAGES=()

    # Obtener todos los paquetes instalados con su arquitectura
    mapfile -t BROKEN_PACKAGES < <(
        dpkg -l | awk '/^ii/ {print $2}' | while IFS= read -r pkg; do
            # Solo corregir wine32:i386 a wine32
            [[ "$pkg" == "wine32:i386" ]] && pkg="wine32"
            # Comprobar si falta el archivo .list
            [ ! -f "$INFO_DIR/$pkg.list" ] && printf '%s\n' "$pkg"
        done
    )

    # Si no hay paquetes rotos, salir silenciosamente
    if [ ${#BROKEN_PACKAGES[@]} -eq 0 ]; then
        return 0
    fi

    # Mostrar paquetes con archivos .list faltantes
    echo "Paquetes con archivos .list faltantes:"
    printf '%s\n' "${BROKEN_PACKAGES[@]}"

    # Reinstalar paquetes automáticamente
    echo "Reinstalando paquetes..."
    check_apt_update
    sudo apt-get install --reinstall -y "${BROKEN_PACKAGES[@]}"
    echo "Reinstalación completada."
}

restore_ldconfig() {
    INFO="${CYAN}[INFO]${NC}"
    OK="${GREEN}[✔]${NC}"
    WARN="${YELLOW}[!]${NC}"
    FAIL="${RED}[✖]${NC}"
    DIR="${CYAN}[DIR]${NC}"
    LOG="${CYAN}[LOG]${NC}"

    TMPDIR="/tmp/libc-bin-restore"
    mkdir -p "$TMPDIR"

    # Comprobación inicial
    if command -v ldconfig >/dev/null 2>&1; then
        return 0
    fi

    echo -e "$WARN ldconfig no encontrado. Procediendo a restaurarlo..."

    # Detectar distribución y versión
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        DISTRO=${ID,,}
        VERSION_ID=${VERSION_ID:-unknown}
    else
        echo -e "$FAIL No se puede determinar la distribución (falta /etc/os-release)."
        return 1
    fi

    ARCH=$(dpkg --print-architecture)
    echo -e "$INFO Sistema detectado: $DISTRO $VERSION_ID ($ARCH)"

    # Obtener URL del paquete libc-bin
    echo -e "$INFO Buscando paquete libc-bin adecuado..."

    case "$DISTRO" in
        ubuntu)
            REPO="http://archive.ubuntu.com/ubuntu"
            ;;
        debian)
            REPO="http://deb.debian.org/debian"
            ;;
        *)
            echo -e "$FAIL Distribución no soportada: $DISTRO"
            return 1
            ;;
    esac

    PKG_VER=$(LC_ALL=C apt-cache policy libc-bin 2>/dev/null | grep "Candidate:" | awk '{print $2}' || true)

    if [ -z "$PKG_VER" ]; then
        echo -e "$WARN No se pudo determinar versión de libc-bin con apt-cache, usando fallback..."
        PKG_URL=$(
            curl -s "${REPO}/dists/${VERSION_CODENAME:-stable}/main/binary-${ARCH}/Packages.gz" \
            | gunzip -c 2>/dev/null \
            | awk '/^Package: libc-bin/{found=1} found && /^Filename:/{print $2; exit}'
        )
    else
        PKG_URL="${REPO}/pool/main/g/glibc/libc-bin_${PKG_VER}_${ARCH}.deb"
    fi

    PKG_NAME=$(basename "$PKG_URL")
    PKG_PATH="$TMPDIR/$PKG_NAME"

    echo -e "$LOG Descargando $PKG_NAME ..."
    wget -q -O "$PKG_PATH" "$PKG_URL"

    # Extraer ldconfig
    echo -e "$INFO Extrayendo paquete..."
    dpkg-deb -x "$PKG_PATH" "$TMPDIR/extracted"

    if [ ! -f "$TMPDIR/extracted/sbin/ldconfig" ]; then
        echo -e "$FAIL No se encontró ldconfig dentro del paquete descargado."
        return 1
    fi

    echo -e "$INFO Copiando ldconfig a /sbin ..."
    cp "$TMPDIR/extracted/sbin/ldconfig" /sbin/
    chmod 755 /sbin/ldconfig

    # Verificación y reparación
    echo -e "$INFO Verificando funcionamiento..."
    if /sbin/ldconfig -p >/dev/null 2>&1; then
        echo -e "$OK ldconfig restaurado correctamente."
    else
        echo -e "$WARN ldconfig copiado pero no parece funcional."
    fi

    echo -e "$INFO Reinstalando libc-bin y reparando dependencias..."
    apt-get install --reinstall -y libc-bin || true
    apt-get -f install -y || true

    # Limpieza
    echo -e "$INFO Limpiando archivos temporales..."
    rm -rf "$TMPDIR"

    echo -e "$OK Proceso completado. ldconfig debería estar operativo."
}

install_shim_if_uefi() {
    # Comprobar si el sistema usa UEFI
    if [ -d /sys/firmware/efi ]; then
        # echo "Sistema UEFI detectado."

        # Comprobar si shim-signed está instalado o solo en estado rc
        PKG_STATUS=$(dpkg -l shim-signed 2>/dev/null | awk '/^ii|^rc/ {print $1}')
        if [[ "$PKG_STATUS" != "ii" ]]; then
            echo "Paquete 'shim-signed' no instalado o estado rc. Procediendo a instalar..."

            # Actualizar lista de paquetes
            apt-get update -qq

            # Descargar el paquete
            apt-get download shim-signed

            # Obtener el nombre del archivo .deb descargado
            DEB_FILE=$(ls shim-signed_*.deb 2>/dev/null | head -n1)

            if [ -n "$DEB_FILE" ]; then
                echo "Instalando $DEB_FILE..."
                dpkg -i "$DEB_FILE"

                # Resolver dependencias automáticamente
                apt-get install -f -y

                rm -f "$DEB_FILE"

                # Comprobar si se instaló correctamente
                if dpkg -s shim-signed >/dev/null 2>&1; then
                    echo "✔ Paquete 'shim-signed' instalado correctamente."
                else
                    echo "✖ Falló la instalación de 'shim-signed'."
                    return 1
                fi
            else
                echo "✖ No se pudo descargar el paquete 'shim-signed'."
                return 1
            fi
        fi
    fi
}

solveapterrors() {
  set +e

  idioma=$LC_ALL
  export LC_ALL=C

  TIMEOUT_UNITS=${TIMEOUT_FOR_DPKG_OR_APT: -1}
  TIMEOUT_NUMBER=${TIMEOUT_FOR_DPKG_OR_APT:: -1}

  case "$TIMEOUT_UNITS" in
     "s")  AFTER_TIMEOUT=$TIMEOUT_NUMBER
           ;;
     "m")  AFTER_TIMEOUT=$(($TIMEOUT_NUMBER * 60))
           ;;
     "h")  AFTER_TIMEOUT=$((expr $TIMEOUT_NUMBER * 3600))
           ;;
     "d")  AFTER_TIMEOUT=$((expr $TIMEOUT_NUMBER * 86400))
           ;;
  esac

  # Matamos procesos detenidos
  stopped_processes=$(ps auwx | awk 'NR>1 && $8 ~ "T" {print $2}')
  if [ "$stopped_processes" ]; then kill -9 $stopped_processes; fi

  # Buscamos procesos dpkg/apt detenidos más de 5 minutos
  unlock_dpkg

  # Restauramos ldconfig si no se encuentra
  restore_ldconfig

  # Instalamos shim en sistemas uefi, si se encuentra en estado ^rc
  install_shim_if_uefi

  # Tratamos de instalar paquetes en estado ic
  wait_while_locked; incomplete_packages=$(dpkg -l|grep ^ic | awk '{print $2}')
  if [ "$incomplete_packages" ]; then
     echo -e "${GREEN}Tratando de reparar paquetes en estado ^ic.${NC}"
     wait_while_locked; apt-get -y install -o Dpkg::Options::="--force-confold" $incomplete_packages
  fi

  # Reinstalamos paquetes en muy mal estado o los desinstalamos si no se pueden reinstalar
  wait_while_locked; very_bad_state_packages=$(dpkg -l|grep "^.HR" | awk '{print $2}')
  if [ "$very_bad_state_packages" ]; then
     echo -e "${GREEN}Tratando de reparar paquetes en muy mal estado.${NC}"

     for packagename in $very_bad_state_packages; do
         mv /var/lib/dpkg/info/$packagename.* /tmp/
         wait_while_locked; dpkg --purge --force-all $packagename
         wait_while_locked; run_aptitude -y install -o Dpkg::Options::="--force-confold" $packagename
         if [ $? -ne 0 ]; then
            wait_while_locked; dpkg --purge --force-all $packagename
         fi
     done
  fi

  # Desinstalamos paquetes en estado de inconsistencia
  wait_while_locked; inconsistent_packages=$(dpkg -l|grep ^iU | awk '{print $2}')
  if [ "$inconsistent_packages" ]; then
     echo -e "${GREEN}Tratando de reparar paquetes en estado ^iU.${NC}"

     for packagename in $inconsistent_packages; do
         mv /var/lib/dpkg/info/$packagename.* /tmp/
         wait_while_locked; dpkg --remove --force-remove-reinstreq $packagename
     done
  fi

  # Reinstalamos paquetes a medio instalar o los desinstalamos si no se pueden reinstalar
  wait_while_locked; bad_packages=$(dpkg -l | grep -e ^iF -e ^ri | awk '{print $2}')
  if [ "$bad_packages" ]; then
     echo -e "${GREEN}Tratando de reinstalar paquetes en estado ^iF o ^ri.${NC}"
     wait_while_locked; run_aptitude -y install -o Dpkg::Options::="--force-confold" $bad_packages
     wait_while_locked; bad_packages=$(dpkg -l | grep -e ^iF -e ^ri | awk '{print $2}')
     if [ "$bad_packages" ]; then
        wait_while_locked; run_aptitude remove -y $bad_packages
        if [ $? -ne 0 ]; then
           wait_while_locked; dpkg --purge --force-all $bad_packages
        fi
     fi
  fi

  wait_while_locked; apt-get check 1>/dev/null 2>/tmp/apterrors

  if [ -s /tmp/apterrors ]; then
     if [ -n "$(grep 'Unable to acquire the dpkg frontend lock' /tmp/apterrors)" ]; then
        if [ $(pgrep -c aptitude) -gt 0 ]; then killprocess aptitude $AFTER_TIMEOUT; fi
        if [ $(pgrep -c apt-get) -gt 0 ]; then killprocess apt-get $AFTER_TIMEOUT; fi
        if [ $(pgrep -c dpkg) -gt 0 ]; then killprocess dpkg $AFTER_TIMEOUT; fi
     fi

     grep "Unmet dependencies." /tmp/apterrors 2>/dev/null && wait_while_locked; run_aptitude -yf install; wait_while_locked; dpkg --configure -a
     grep "dpkg was interrupted, you must manually run 'dpkg --configure -a' to correct the problem." /tmp/apterrors 2>/dev/null && wait_while_locked; dpkg --configure -a; run_aptitude -yf install
     grep -E 'Encountered a section with no Package: header|Problem with MergeList ' /tmp/apterrors 2>/dev/null && rm -r /var/lib/apt/lists/*; wait_while_locked; check_apt_update; wait_while_locked; dpkg --configure -a; wait_while_locked; run_aptitude -yf install
  fi

  # Reinstalamos paquetes con ficheros .list faltantes
  reinstall_broken_dpkg

  export LC_ALL=$idioma
}

apagar_equipo() {
  # Apagar el equipo si el usuario pasó el parámetro -S
  if [ $SHUTDOWN = true ]; then wait_while_locked; /sbin/poweroff; fi
}

reiniciar_equipo() {
  # Reiniciar el equipo si el usuario pasó el parámetro -R
  if [ $REBOOT = true ]; then wait_while_locked; /sbin/reboot; fi
}


SHUTDOWN=false # No apagar
REBOOT=false   # No reiniciar
THRESHOLD_FOR_APT_UPDATE=$((30 * 60)) # Definir el umbral de tiempo en segundos (por defecto 30 minutos = 1800 segundos)

RED='\033[0;31m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color

if (( $EUID != 0 )); then
   echo -e "${RED}Please run with SUDO or root user account${NC}"
   exit 1
fi

TIMEOUT_FOR_DPKG_OR_APT="3m"

# Leer y procesar argumentos
while getopts "hSR" opt
do
    case $opt in
        h ) print_help
            exit ;;
        S ) SHUTDOWN=true ;;
        R ) REBOOT=true ;;
        \? ) echo "Opcion invalida -$OPTARG"
          exit 1 ;;
        : ) echo "Opcion -$OPTARG requiere un argumento"
          exit 1 ;;
    esac
done
shift $((OPTIND-1))

lockfile="/tmp/softwareupdate.lock"
trap "rm -f $lockfile" EXIT
touch $lockfile

# Obtenemos claves públicas de repositorios si se encuentra launchpad-getkeys
[ -x /usr/local/sbin/launchpad-getkeys ] && echo -e "${GREEN}\nObteniendo claves públicas de repositorios...${NC}" && /usr/local/sbin/launchpad-getkeys

# Resolvemos errores de apt, si los hay
wait_while_locked; solveapterrors

# Instalamos el paquete linux-headers-generic-hwe-22.04 si el paquete linux-image-generic-hwe-22.04 se encuentra instalado
if dpkg -l | grep -q "^ii  linux-image-generic-hwe-22.04 " && ! dpkg -l | grep -q "ii  linux-headers-generic-hwe-22.04 "; then
   $APT_COMMAND $APT_ARGS install linux-headers-generic-hwe-22.04
fi

# Si existen paquetes deb actualizables, los actualizamos
UPDATES=$(apt-get -s upgrade | grep "Inst" | wc -l)
if [ "$UPDATES" -gt 0 ]; then
   [ -x $APT_COMMAND ] && echo -e "${GREEN}\nActualizando paquetes...\n${NC}" && check_apt_update; disable_failed_repositories; $APT_COMMAND $APT_ARGS dist-upgrade; enable_repositories
else
   echo -e "\n${GREEN}Los paquetes deb del sistema se encuentran completamente actualizados.${NC}"
fi

# Si se encuentra instalado flatpak, actualizamos el software instalado mediante flatpak
[ -x /usr/bin/flatpak ] && echo -e "${GREEN}\nActualizando software instalado mediante flatpak...\n${NC}"  && /usr/bin/flatpak update -y

# Si se encuentra instalado snap, actualizamos el software instalado mediante snap
[ -x /usr/bin/snap ] && echo -e "${GREEN}\nActualizando software instalado via snap...\n${NC}"  && /usr/bin/snap refresh

# Realizamos limpieza de paquetes
echo -e "${GREEN}\nRealizando limpieza de paquetes...\n${NC}"

wait_while_locked; apt-get -fy install &&
wait_while_locked; dpkg --configure -a &&
wait_while_locked; apt-get -y remove --purge $(dpkg -l| grep ^rc | awk '{print $2}') &&
#wait_while_locked; apt-get -y --no-install-recommends autoremove &&
wait_while_locked; $APT_COMMAND -y clean

[ $(which flatpak) ] && flatpak uninstall --unused -y
[ $(which snap) ] && LANG=C snap list --all | awk '/disabled/{print $1, $3}' |
  while read snapname revision; do
     snap remove "$snapname" --revision="$revision"
  done

[ -f /tmp/apterrors ] && rm -f /tmp/apterrors

apagar_equipo && reiniciar_equipo

rm -f $lockfile
