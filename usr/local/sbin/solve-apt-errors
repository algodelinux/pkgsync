#!/bin/bash
# solve-apt-errors - Trata de resolver posibles errores de apt
# 2013-2025 Esteban M. Navas Martín <algodelinux@gmail.com>.
# Last update: 11/11/2025

idioma=$LC_ALL
export LC_ALL=C
export DEBIAN_FRONTEND=noninteractive

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW="\033[33m"
CYAN="\033[36m"
NC='\033[0m' # No Color


killprocess() {

   updatehour=$(ps aux|grep $1 | grep -v grep | head -1 | awk '{print $9}')
   if [ -n $updatehour ]; then
      timestampupdate=$(date -d "$updatehour" +'%s')
      timestampnow=$(date +'%s')
      diference=$(($timestampnow - $timestampupdate))
      minutesfromupdate=$(($diference / 60))

      if [ "$minutesfromupdate" -gt "$2" ]; then
         # Matamos proceso
         pkill -9 $1 2>/dev/null
      fi
   fi
}

wait_while_locked() {
   [ -x /usr/local/sbin/wait_for_apt_or_dpkg ] && timeout $TIMEOUT_FOR_DPKG_OR_APT /usr/local/sbin/wait_for_apt_or_dpkg
}

unlock_dpkg() {
    local TIME_MINUTES="${1:-5}"
    local LOG_FILE="/var/log/solve-apt-errors.log"

    # For testing purposes only
    # echo -e "${CYAN}Buscando procesos dpkg/apt bloqueados o configurando paquetes desde más de $TIME_MINUTES minutos...${NC}" | tee -a "$LOG_FILE"

    ps -eo pid,etime,comm,args --sort=etime | while read -r PID ETIME COMM ARGS; do
        # Solo dpkg o apt
        if [[ "$COMM" != "dpkg" && "$COMM" != "apt" ]]; then
            continue
        fi

        # Convertir ETIME a minutos aproximados
        minutes=0
        if [[ $ETIME =~ - ]]; then
            # D-HH:MM o D-HH:MM:SS
            IFS=- read -r DAYS TIME_PART <<< "$ETIME"
            IFS=: read -r H M S <<< "$TIME_PART:0:0"
            minutes=$((DAYS*24*60 + H*60 + M))
        else
            # HH:MM:SS o MM:SS
            IFS=: read -r H M S <<< "$ETIME:0:0"
            H=${H:-0}
            M=${M:-0}
            minutes=$((H*60 + M))
        fi

        if [ "$minutes" -ge "$TIME_MINUTES" ]; then
            # Identificar si está configurando un paquete
            ACTION_DESC="bloqueado"
            [[ "$ARGS" == *"--configure"* ]] && ACTION_DESC="configurando paquetes"

            echo -e "${RED}Proceso $PID ($COMM) $ACTION_DESC lleva $minutes minutos. Terminando...${NC}" | tee -a "$LOG_FILE"

            kill -TERM "$PID" 2>/dev/null
            sleep 2
            if ps -p "$PID" > /dev/null; then
                echo -e "${RED}Proceso $PID no terminó, forzando KILL...${NC}" | tee -a "$LOG_FILE"
                kill -KILL "$PID" 2>/dev/null
            fi
        fi
    done

}

reinstall_broken_dpkg() {
    local INFO_DIR="/var/lib/dpkg/info"
    local BROKEN_PACKAGES=()

    # Iterar sobre paquetes instalados
    for pkg in $(dpkg -l | awk '/^ii/ {print $2}'); do
        if [ ! -f "$INFO_DIR/${pkg}.list" ]; then
            BROKEN_PACKAGES+=("$pkg")
        fi
    done

    # Si no hay paquetes rotos, salir silenciosamente
    if [ ${#BROKEN_PACKAGES[@]} -eq 0 ]; then
        return 0
    fi

    # Mostrar solo si hay paquetes con archivos .list faltantes
    echo "Paquetes con archivos .list faltantes:"
    printf '%s\n' "${BROKEN_PACKAGES[@]}"

    echo "Reinstalando paquetes automáticamente..."
    apt-get update; apt-get install --reinstall -y "${BROKEN_PACKAGES[@]}"
    echo "Reinstalación completada."
}

restore_ldconfig() {

    INFO="${CYAN}[INFO]${NC}"
    OK="${GREEN}[✔]${NC}"
    WARN="${YELLOW}[!]${NC}"
    FAIL="${RED}[✖]${NC}"
    DIR="${CYAN}[DIR]${NC}"
    LOG="${CYAN}[LOG]${NC}"

    TMPDIR="/tmp/libc-bin-restore"
    mkdir -p "$TMPDIR"

    # Comprobación inicial
    if command -v ldconfig >/dev/null 2>&1; then
        return 0
    fi

    echo -e "$WARN ldconfig no encontrado. Procediendo a restaurarlo..."

    # Detectar distribución y versión
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        DISTRO=${ID,,}
        VERSION_ID=${VERSION_ID:-unknown}
    else
        echo -e "$FAIL No se puede determinar la distribución (falta /etc/os-release)."
        return 1
    fi

    ARCH=$(dpkg --print-architecture)
    echo -e "$INFO Sistema detectado: $DISTRO $VERSION_ID ($ARCH)"

    # Obtener URL del paquete libc-bin
    echo -e "$INFO Buscando paquete libc-bin adecuado..."

    case "$DISTRO" in
        ubuntu)
            REPO="http://archive.ubuntu.com/ubuntu"
            ;;
        debian)
            REPO="http://deb.debian.org/debian"
            ;;
        *)
            echo -e "$FAIL Distribución no soportada: $DISTRO"
            return 1
            ;;
    esac

    PKG_VER=$(LC_ALL=C apt-cache policy libc-bin 2>/dev/null | grep "Candidate:" | awk '{print $2}' || true)

    if [ -z "$PKG_VER" ]; then
        echo -e "$WARN No se pudo determinar versión de libc-bin con apt-cache, usando fallback..."
        PKG_URL=$(
            curl -s "${REPO}/dists/${VERSION_CODENAME:-stable}/main/binary-${ARCH}/Packages.gz" \
            | gunzip -c 2>/dev/null \
            | awk '/^Package: libc-bin/{found=1} found && /^Filename:/{print $2; exit}'
        )
    else
        PKG_URL="${REPO}/pool/main/g/glibc/libc-bin_${PKG_VER}_${ARCH}.deb"
    fi

    PKG_NAME=$(basename "$PKG_URL")
    PKG_PATH="$TMPDIR/$PKG_NAME"

    echo -e "$LOG Descargando $PKG_NAME ..."
    wget -q -O "$PKG_PATH" "$PKG_URL"

    # Extraer ldconfig
    echo -e "$INFO Extrayendo paquete..."
    dpkg-deb -x "$PKG_PATH" "$TMPDIR/extracted"

    if [ ! -f "$TMPDIR/extracted/sbin/ldconfig" ]; then
        echo -e "$FAIL No se encontró ldconfig dentro del paquete descargado."
        return 1
    fi

    echo -e "$INFO Copiando ldconfig a /sbin ..."
    cp "$TMPDIR/extracted/sbin/ldconfig" /sbin/
    chmod 755 /sbin/ldconfig

    # Verificación y reparación
    echo -e "$INFO Verificando funcionamiento..."
    if /sbin/ldconfig -p >/dev/null 2>&1; then
        echo -e "$OK ldconfig restaurado correctamente."
    else
        echo -e "$WARN ldconfig copiado pero no parece funcional."
    fi

    echo -e "$INFO Reinstalando libc-bin y reparando dependencias..."
    apt-get install --reinstall -y libc-bin || true
    apt-get -f install -y || true

    # Limpieza
    echo -e "$INFO Limpiando archivos temporales..."
    rm -rf "$TMPDIR"

    echo -e "$OK Proceso completado. ldconfig debería estar operativo."
}

install_shim_if_uefi() {
    # Comprobar si el sistema usa UEFI
    if [ -d /sys/firmware/efi ]; then
        # echo "Sistema UEFI detectado."

        # Comprobar si shim-signed está instalado o solo en estado rc
        PKG_STATUS=$(dpkg -l shim-signed 2>/dev/null | awk '/^ii|^rc/ {print $1}')
        if [[ "$PKG_STATUS" != "ii" ]]; then
            echo "Paquete 'shim-signed' no instalado o estado rc. Procediendo a instalar..."

            # Actualizar lista de paquetes
            apt-get update -qq

            # Descargar el paquete
            apt-get download shim-signed

            # Obtener el nombre del archivo .deb descargado
            DEB_FILE=$(ls shim-signed_*.deb 2>/dev/null | head -n1)

            if [ -n "$DEB_FILE" ]; then
                echo "Instalando $DEB_FILE..."
                dpkg -i "$DEB_FILE"

                # Resolver dependencias automáticamente
                apt-get install -f -y

                rm -f "$DEB_FILE"

                # Comprobar si se instaló correctamente
                if dpkg -s shim-signed >/dev/null 2>&1; then
                    echo "✔ Paquete 'shim-signed' instalado correctamente."
                else
                    echo "✖ Falló la instalación de 'shim-signed'."
                    return 1
                fi
            else
                echo "✖ No se pudo descargar el paquete 'shim-signed'."
                return 1
            fi
        fi
    fi
}


if (( $EUID != 0 )); then
   echo -e "${RED}Please run with SUDO or root user account${NC}"
   exit 1
fi

# Tiempo máximo en minutos que puede estar corriendo sinc_puppet antes de matarlo
TIMEOUT_FOR_SINC_PUPPET="5"
# Tiempo máximo de espera a que dpkg o apt hayan terminado antes de realizar pkgsync 
# Este ajuste puede definirse en segundos (30 o 30s), minutos (10m), horas (6h) o días (2d).
TIMEOUT_FOR_DPKG_OR_APT="3m"

if [ -f /etc/default/pkgsync ]; then
   TIMEOUT_FOR_DPKG_OR_APT=$(grep -v "^#" /etc/default/pkgsync | sed -n 's|TIMEOUT_FOR_DPKG_OR_APT="\(.*\)"|\1|p')
   TIMEOUT_FOR_SINC_PUPPET=$(grep -v "^#" /etc/default/pkgsync | sed -n 's|TIMEOUT_FOR_SINC_PUPPET="\(.*\)"|\1|p')
fi

if [ -s "$TIMEOUT_FOR_DPKG_OR_APT" ]; then
   TIMEOUT_UNITS=${TIMEOUT_FOR_DPKG_OR_APT: -1}
   TIMEOUT_NUMBER=${TIMEOUT_FOR_DPKG_OR_APT:: -1}
fi

case "$TIMEOUT_UNITS" in

"s")  AFTER_TIMEOUT=$TIMEOUT_NUMBER
    ;;
"m")  AFTER_TIMEOUT=$(($TIMEOUT_NUMBER * 60))
    ;;
"h")  AFTER_TIMEOUT=$((expr $TIMEOUT_NUMBER * 3600))
    ;;
"d")  AFTER_TIMEOUT=$((expr $TIMEOUT_NUMBER * 86400))
   ;;
esac

if [ "$1" == "-f" ]; then
   $TIMEOUT_FOR_SINC_PUPPET=0
   $AFTER_TIMEOUT=0
fi

# Matamos procesos detenidos
stopped_processes=$(ps auwx | awk 'NR>1 && $8 ~ "T" {print $2}')
if [ "$stopped_processes" ]; then kill -9 $stopped_processes; fi

# Matamos sinc_puppet si está corriendo desde hace más de xx minutos
if [ $(pgrep -c sinc_puppet) -gt 0 ]; then killprocess sinc_puppet $TIMEOUT_FOR_SINC_PUPPET; fi

# Buscamos procesos dpkg/apt detenidos más de 5 minutos (valor por defecto)
unlock_dpkg

# Restauramos ldconfig si no se encuentra
restore_ldconfig

# Instalamos shim en sistemas uefi, si se encuentra en estado ^rc
install_shim_if_uefi

# Tratamos de instalar paquetes en estado ic
wait_while_locked; incomplete_packages=$(dpkg -l|grep ^ic | awk '{print $2}')
if [ "$incomplete_packages" ]; then
   wait_while_locked; apt-get -y install -o Dpkg::Options::="--force-confold" $incomplete_packages
fi

# Reinstalamos paquetes en muy mal estado o los desinstalamos si no se pueden reinstalar
wait_while_locked; very_bad_state_packages=$(dpkg -l|grep "^.HR" | awk '{print $2}')
if [ "$very_bad_state_packages" ]; then
   for packagename in $very_bad_state_packages; do
       mv /var/lib/dpkg/info/$packagename.* /tmp/
       wait_while_locked; dpkg --purge --force-all $packagename
       wait_while_locked; apt-get -y install -o Dpkg::Options::="--force-confold" $packagename
       if [ $? -ne 0 ]; then
          wait_while_locked; dpkg --purge --force-all $packagename
       fi
   done
fi

# Desinstalamos paquetes en estado de inconsistencia
wait_while_locked; inconsistent_packages=$(dpkg -l|grep ^iU | awk '{print $2}')
if [ "$inconsistent_packages" ]; then
   for packagename in $inconsistent_packages; do
       mv /var/lib/dpkg/info/$packagename.* /tmp/
       wait_while_locked; dpkg --remove --force-remove-reinstreq $packagename
   done
fi

# Reinstalamos paquetes a medio instalar o los desinstalamos si no se pueden reinstalar
wait_while_locked; bad_packages=$(dpkg -l | grep -e ^iF -e ^ri | awk '{print $2}')
if [ "$bad_packages" ]; then
   wait_while_locked; apt-get -y install -o Dpkg::Options::="--force-confold" $bad_packages
   wait_while_locked; bad_packages=$(dpkg -l | grep -e ^iF -e ^ri | awk '{print $2}')
   if [ "$bad_packages" ]; then
      wait_while_locked; apt-get remove -y $bad_packages
      if [ $? -ne 0 ]; then
         wait_while_locked; dpkg --purge --force-all $bad_packages
      fi
   fi
fi

wait_while_locked; apt-get check 1>/dev/null 2>/tmp/apterrors

if [ -s /tmp/apterrors ]; then
   if [ -n "$(grep 'Unable to acquire the dpkg frontend lock' /tmp/apterrors)" ]; then
      if [ $(pgrep -c aptitude) -gt 0 ]; then killprocess aptitude $AFTER_TIMEOUT; fi
      if [ $(pgrep -c apt-get) -gt 0 ]; then killprocess apt-get $AFTER_TIMEOUT; fi
      if [ $(pgrep -c dpkg) -gt 0 ]; then killprocess dpkg $AFTER_TIMEOUT; fi
   fi

   grep "Unmet dependencies." /tmp/apterrors 2>/dev/null && wait_while_locked; aptitude -yf install; wait_while_locked; dpkg --configure -a
   grep "dpkg was interrupted, you must manually run 'dpkg --configure -a' to correct the problem." /tmp/apterrors 2>/dev/null && wait_while_locked; dpkg --configure -a; wait_while_locked; aptitude -yf install
   grep -E 'Encountered a section with no Package: header|Problem with MergeList ' /tmp/apterrors 2>/dev/null && rm -r /var/lib/apt/lists/*; wait_while_locked; apt-get update -y; wait_while_locked; dpkg --configure -a; wait_while_locked; aptitude -yf install
fi

# Reinstalamos paquetes con archivos .list faltantes
reinstall_broken_dpkg

# Aseguramos la actualización de pkgsync
wait_while_locked; apt-cache search '~U' | grep -oE pkgsync >/dev/null 2>&1 && apt-get -y install -o Dpkg::Options::="--force-confold" pkgsync

export LC_ALL=$idioma
