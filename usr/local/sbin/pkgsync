#! /bin/bash
#
# pkgsync - Automated package synchronization tool
# 2004-2007 Steinar H. Gunderson <sgunderson@bigfoot.com>.
# 2013-2018 Esteban M. Navas Martín <algodelinux@gmail.com>.
#

set -e
set -o noglob
export DEBIAN_FRONTEND=noninteractive
export VERSION=1.47

print_help () {
	echo "pkgsync $VERSION"
	echo "Automated package synchronization tool"
	echo ""
	echo "Usage: pkgsync [OPTIONS]"
	echo "Recognized options:"
	echo "  -h, --help                	display this help and exit"
	echo "  -k, --keep-unused         	don't remove unused packages"
	echo "  -s, --simulate            	don't do anything, just print out what would have happened"
	echo "  -d, --dpkg-glob           	use dpkg's globbing (deprecated)"
	echo "  -a, --aptitude-glob       	use aptitude's globbing (default, recommended)"
	echo "  -t, --test-files          	test pkgsync files"
	echo "  -f, --force               	force pkgsync"
	echo "  -c, --clean               	remove uninstalled packages dependencies,
                                                purge uninstalled packages and clean cache"
	echo "  -p, --purge-old-kernels   	remove old kernels keeping the last two"
	echo "  -r, --remove-orphan-libs  	remove orphan libs"
	echo "  -S, --shutdown            	shutdown machine after pkgsync"
	echo "  -R, --reboot              	reboot machine after pkgsync"
	echo ""
	echo "Complete documentation can be found in /usr/share/doc/pkgsync/README.Debian."
}

test_files () {
  :>/var/log/pkgsync/removefromlist.log

  for fichero in $(find /etc/pkgsync -type f -not -name *.all); do
    echo "Checking $fichero"
    while read paquete; do
       existe=$(apt-cache policy $paquete 2>/dev/null)
       if [ ! "$existe" ]; then
          echo "Package $paquete in file $fichero isn't in repositories"
          echo "Package $paquete in file $fichero isn't in repositories" >> /var/log/pkgsync/removefromlist.log
       fi
    done < $fichero
  done
  echo "See /var/log/pkgsync/removefromlist.log"
}

# Largely adapted from /usr/lib/getopt/parse.bash
parse_options () {
	TEMP=`getopt -o hftksadcprSR --long help,force,test-files,keep-unused,simulate,dpkg-glob,aptitude-glob,clean,purge-old-kernels,remove-orphan-libs,shutdown,reboot -n 'pkgsync' -- "$@"`
	eval set -- "$TEMP"

	APTITUDE_ARGS="-y -q -o Dpkg::Options::=--force-confdef -o Dpkg::Options::=--force-confold"
	GLOB_STYLE="aptitude"

	while :; do
		case "$1" in
			-s|--simulate)
				APTITUDE_ARGS="$APTITUDE_ARGS -s"
				shift
				;;
			-k|--keep-unused)
				APTITUDE_ARGS="$APTITUDE_ARGS -o Aptitude::Delete-Unused=false"
				shift
				;;
			-d|--dpkg-glob)
				GLOB_STYLE="dpkg"
				shift
				;;
			-a|--aptitude-glob)
				GLOB_STYLE="aptitude"
				shift
				;;
			-f|--force)
				FORCE=true
				shift
				;;
			-c|--clean)
				CLEAN="yes"
				shift
				;;
			-p|--purge-old-kernels)
				PURGE_OLD_KERNELS="yes"
				shift
				;;
			-r|--remove-orphan-libs)
				REMOVE_ORPHAN_LIBS="yes"
				shift
				;;
			-S|--shutdown)
				SHUTDOWN=true
				shift
				;;
			-R|--reboot)
				REBOOT=true
				shift
				;;
			-t|--test-files)
				test_files
				exit 0
				;;
			-h|--help)
				print_help
				exit 0
				;;
			--)
				shift
				break
				;;
			*)
				echo "Internal error: doesn't recognize argument '$1'"
				exit 1
				;;
		esac
	done
}
readpkgs () {
	grep -vE '^#' "$1" | grep -vE '^\s*$' | tr -d " \t"
}
getpkgs () {
	IFS="
"
	for pkg in $( readpkgs $1 ); do
		# if the line starts with "debtags:", it's a debtags expression,
		# so run it through debtags.
		if echo "$pkg" | grep -Eq '^debtags:'; then
			if ! [ "$USE_DEBTAGS" ]; then
				echo Error: "debtags:" line encountered, but debtags is not installed. Stopping.
				exit 1
			fi
			PATTERN=$( echo "$pkg" | cut -d: -f2- )
			debtags grep "$PATTERN" | tagcoll copy | cut -d: -f1
		else
			# if the line is "meta:current-kernel", use the kernel package
			# for the currently running kernel, if it exists
			if [ "$pkg" = "meta:current-kernel" ]; then
				KVERS=$( uname -r )
				if [ "$GLOB_STYLE" = "dpkg" ]; then
					dpkg-query --showformat '${Package}\n' -W "*-image-$KVERS" 2>/dev/null || true
				else
					aptitude -F '%p' search ".*-image-$KVERS$" | sed "s/ \+$//" 2>/dev/null || true
				fi
			else
				# if there's a wildcard in this, push it through dpkg/aptitude
				# to glob. if not, just print it out.
				if [ "$GLOB_STYLE" = "dpkg" ]; then
					if echo "$pkg" | grep -Eq '[][*?]'; then
						dpkg-query --showformat '${Package}\n' -W "$pkg" 2>/dev/null || true
					else
						echo "$pkg"
					fi
				else
					if echo "$pkg" | grep -Eq '[][*?()|~]'; then
						aptitude -F '%p' search "$pkg" | sed "s/ \+$//" 2>/dev/null || true
					else
						echo "$pkg"
					fi
				fi
			fi
		fi
	done
}
run_aptitude () {
	echo RUNNING: aptitude $APTITUDE_ARGS "$@"
	aptitude $APTITUDE_ARGS "$@"
}
run_debtags () {
	if [ "$USE_DEBTAGS" ]; then
		echo RUNNING: debtags "$@"
		debtags "$@"
	fi
}

# The beautiful look of hacks in the morning...
filter () {
	echo "$@" | tr " " "\n" | sort | uniq -c | grep "     2" | cut -c9-
}

function version_ge() { test "$(echo "$@" | tr " " "\n" | sort -rV | head -n 1)" == "$1"; }

wait_for_apt_or_dpkg() {
  # Esperamos mientras se esté realizando una actualización de índices o una actualización de paquetes
  if [ $(lsof /var/lib/apt/lists/lock 2>/dev/null | awk '{print $1}' | tail -1) ] || [ $(lsof /var/lib/dpkg/lock 2>/dev/null | awk '{print $1}' | tail -1) ]; then
     echo "Esperando mientras se actualizan índices o paquetes..."
  fi
  while [ $(lsof /var/lib/apt/lists/lock 2>/dev/null | awk '{print $1}' | tail -1) ] || [ $(lsof /var/lib/dpkg/lock 2>/dev/null | awk '{print $1}' | tail -1) ]; do
     sleep 1
  done
}

solveapterrors() {
  idioma=$LC_ALL
  export LC_ALL=C

  timeout $TIMEOUT_FOR_DPKG_OR_APT wait_for_apt_or_dpkg; apt-get check 1>/dev/null 2>/tmp/apterrors

  if [ -s /tmp/apterrors ]; then
     timeout $TIMEOUT_FOR_DPKG_OR_APT wait_for_apt_or_dpkg
     grep "Unmet dependencies. Try using -f." /tmp/apterrors && apt-get -yf install && dpkg --configure -a && apt-get -y autoremove
     grep "dpkg was interrupted, you must manually run 'dpkg --configure -a' to correct the problem." /tmp/apterrors && dpkg --configure -a && apt-get -yf install && apt-get -y autoremove
     grep -E 'Encountered a section with no Package: header|Problem with MergeList ' /tmp/apterrors && rm -rf /var/lib/apt/lists/
  fi

  export LC_ALL=$idioma
}

eliminar_kernels() {
  # Eliminar kernels antiguos siempre y cuando se haya elegido esta opción y se encuentre /usr/bin/purge-old-kernels
  if [ $PURGE_OLD_KERNELS = "yes" ] && [ -x /usr/local/sbin/purge-old-kernels ]; then timeout $TIMEOUT_FOR_DPKG_OR_APT wait_for_apt_or_dpkg; /usr/local/sbin/purge-old-kernels --keep $KEEP_LAST_KERNELS -qy; fi
}

launchpad_getkeys() {
  # Obtener claves de repositorios siempre y cuando se haya elegido esta opción y se encuentre /usr/bin/launchpad-getkeys
  if [ $LAUNCHPAD_GETKEYS = "yes" ] && [ -x /usr/bin/launchpad-getkeys ]; then /usr/bin/launchpad-getkeys; fi
}

eliminar_paquetes_huerfanos() {
  # Eliminar librerías huérfanas
  if [ $REMOVE_ORPHAN_LIBS = "yes" ] && [ -x /usr/bin/deborphan ]; then
    /usr/bin/deborphan>/tmp/orphan_libs
    if [ -s /tmp/orphan_libs ]; then
       sort -o /tmp/orphan_libs /tmp/orphan_libs
       timeout $TIMEOUT_FOR_DPKG_OR_APT wait_for_apt_or_dpkg; apt-get -y remove --purge $(cat /tmp/orphan_libs)
       echo "Remove these packages from musthave files:" > /var/log/pkgsync/removefrommusthave.log
       echo > /var/log/pkgsync/removefrommusthave.log
       cat /tmp/orphan_libs >> /var/log/pkgsync/removefrommusthave.log
       sed -e "s/:.*$//" /tmp/orphan_libs | sort -u > /etc/pkgsync/musthave.orphan
    fi
  fi
}

eliminar_dependencias() {
  # Eliminar dependencias innecesarias de paquetes desinstalados, purgar paquetes desinstalados y limpiar la cache
  if [ $CLEAN = "yes" ]; then
     timeout $TIMEOUT_FOR_DPKG_OR_APT wait_for_apt_or_dpkg; apt-get -y autoremove
     timeout $TIMEOUT_FOR_DPKG_OR_APT wait_for_apt_or_dpkg; apt-get -y remove --purge $(dpkg -l| grep ^rc | awk '{print $2}')
     timeout $TIMEOUT_FOR_DPKG_OR_APT wait_for_apt_or_dpkg; apt-get -y clean
  fi
}

apagar_equipo() {
  # Apagar el equipo si el usuario pasó el parámetro -S
  if [ $SHUTDOWN = true ]; then timeout $TIMEOUT_FOR_DPKG_OR_APT wait_for_apt_or_dpkg;/sbin/poweroff; fi
}

reiniciar_equipo() {
  # Reiniciar el equipo si el usuario pasó el parámetro -R
  if [ $REBOOT = true ]; then timeout $TIMEOUT_FOR_DPKG_OR_APT wait_for_apt_or_dpkg;/sbin/reboot; fi
}

check_auto_shutdown() {
  time=$(date +%H%M)

  if [ -n "$AUTOMATIC_SHUTDOWN_BETWEEN" ]; then
     (echo "$AUTOMATIC_SHUTDOWN_BETWEEN" | grep -Eq ^[0-9]{2}:[0-9]{2}-[0-9]{2}:[0-9]{2}$)
     horaini=$(expr match "$AUTOMATIC_SHUTDOWN_BETWEEN" '\(..:..\)' | tr -d ':')
     horafin=$(expr "$AUTOMATIC_SHUTDOWN_BETWEEN" : '.*\(..:..\)' | tr -d ':')

     if [ "$horaini" -lt "$horafin" ]; then
        [ "$time" -ge "$horaini" ] && [ "$time" -le "$horafin" ] && SHUTDOWN=true || SHUTDOWN=false
     else
        if [ "$horaini" -gt "$horafin" ]; then
           [ "$time" -le "$horaini" ] && [ "$time" -le "$horafin" ] && SHUTDOWN=true || SHUTDOWN=false
        fi
     fi
  fi

  # Defined only for testing purposes
  # echo hora actual: $time
  # echo $SHUTDOWN
  # echo hora inicio: [$horaini]
  # echo hora fin: [$horafin]
}

check_auto_reboot() {
  time=$(date +%H%M)

  if [ -n "$AUTOMATIC_REBOOT_BETWEEN" ]; then
     (echo "$AUTOMATIC_REBOOT_BETWEEN" | grep -Eq ^[0-9]{2}:[0-9]{2}-[0-9]{2}:[0-9]{2}$)
     horaini=$(expr match "$AUTOMATIC_REBOOT_BETWEEN" '\(..:..\)' | tr -d ':')
     horafin=$(expr "$AUTOMATIC_REBOOT_BETWEEN" : '.*\(..:..\)' | tr -d ':')

     if [ "$horaini" -lt "$horafin" ]; then
        [ "$time" -ge "$horaini" ] && [ "$time" -le "$horafin" ] && REBOOT=true || REBOOT=false
     else
        if [ "$horaini" -gt "$horafin" ]; then
           [ "$time" -le "$horaini" ] && [ "$time" -le "$horafin" ] && REBOOT=true || REBOOT=false
        fi
     fi
  fi

  # Defined only for testing purposes
  # echo hora actual: $time
  # echo $REBOOT
  # echo hora inicio: [$horaini]
  # echo hora fin: [$horafin]

  if [ $REBOOT ] && [ "$AUTOMATIC_REBOOT_INTO_WINDOWS" = "yes" ] && [ -x /bin/efibootmgr ]; then
     # Obtenemos el orden de arranque actual
     bootorder=$(/bin/efibootmgr | sed -n 's|^BootOrder: \(.*\)|\1|p')

     # Creamos una entrada específica para Windows 10, si no está creada
     /bin/efibootmgr | grep "W10IES" 2>&1 > /dev/null || /bin/efibootmgr -c -d $EFI_DISK -p $(gdisk -l $EFI_DISK | grep "EFI system partition" | awk '{print $1}') -L "W10IES" -l "\EFI\Microsoft\Boot\bootmgfw.efi"

     # Restauramos el bootorder
     /bin/efibootmgr -o $bootorder

     # Establecemos un arranque temporal de Windows
     /bin/efibootmgr -n $(/bin/efibootmgr | grep "W10IES" | sed -ne 's/[^0-9A-F]*\(\([0-9A-F]\)\{4\}\).*/\1/p') 2>&1>/dev/null
  fi
}

# Matamos procesos detenidos
stopped_processes=$(ps auwx | awk 'NR>1 && $8 ~ "T" {print $2}')
if [ "$stopped_processes" ]; then kill -9 $stopped_processes; fi

# Establecemos valores por defecto
HELP=false
FORCE=false
SHUTDOWN=false # No apagar
REBOOT=false   # No reiniciar
PURGE_OLD_KERNELS=no
KEEP_LAST_KERNELS="2"
CLEAN=no
REMOVE_ORPHAN_LIBS=no
LAUNCH_SINC_PUPPET=yes
AUTOMATIC_SHUTDOWN_BETWEEN=""
AUTOMATIC_REBOOT_BETWEEN=""
AUTOMATIC_REBOOT_INTO_WINDOWS=no
LAUNCHPAD_GETKEYS=yes
TIMEOUT_FOR_DPKG_OR_APT="3m"
EFI_DISK=/dev/sda # Disco que contiene EFI

# Controlamos la ejecución manual o automática de pkgsync
ENABLE=yes
[ -r /etc/default/pkgsync ] && . /etc/default/pkgsync

parse_options "$@"

$FORCE && ENABLE=yes
if [ "$ENABLE" == "no" ] || [ ! "$ENABLE" ]; then
  echo " * [info]: La aplicación 'pkgsync' está desactivada en /etc/default/pkgsync."
  echo "           Para activarla poner el valor ENABLE=yes."
  exit 0
fi

# No ejecutar pkgsync cuando falta alguno de los ficheros musthave, mayhave o maynothave
if [ ! -r /etc/pkgsync/musthave -o \
     ! -r /etc/pkgsync/mayhave -o \
     ! -r /etc/pkgsync/maynothave ]; then
	echo Error: Missing files in /etc/pkgsync. Aborting.
	echo
	echo Please see /usr/share/doc/pkgsync/README.Debian for information on
	echo configuring pkgsync.

	exit 1
fi

# Check if we've got debtags installed
[ -x /usr/bin/debtags ] && USE_DEBTAGS=yes

# Determinar si se debe apagar el equipo al terminar
check_auto_shutdown

# Determinar si se debe reiniciar el equipo al terminar
check_auto_reboot

# Descargar claves de repositorios
launchpad_getkeys

# Aseguramos el estado de los paquetes y eliminamos kernels antiguos
solveapterrors;eliminar_kernels

runned_sinc_puppet=false
# Si está corriendo sinc_puppet, esperamos hasta que termine
if [ $(pgrep sinc_puppet) ]; then
   echo "Esperando a que termine sinc_puppet..."
   runned_sinc_puppet=true
fi

while [ $(pgrep sinc_puppet) ]; do
   sleep 1
done

# Si se encuentra sinc_puppet, y no ha sido iniciado previamente, lo iniciamos
if [ $runned_sinc_puppet = false ]; then
   installed_version=$(dpkg -s linex-ubuntu-puppet 2>/dev/null | grep 'Version:' | cut -f2 -d" ")
   if version_ge $installed_version "2.7"; then
      if [ $LAUNCH_SINC_PUPPET = "yes" ] && [ -x /usr/sbin/sinc_puppet ]; then /usr/sbin/sinc_puppet -f now; fi
   else
      if [ $LAUNCH_SINC_PUPPET = "yes" ] && [ -x /usr/sbin/sinc_puppet ]; then /usr/sbin/sinc_puppet -f; fi
   fi
fi

# Update the package lists
timeout $TIMEOUT_FOR_DPKG_OR_APT wait_for_apt_or_dpkg;aptitude update
run_debtags update

# Create ies files if don't exists
test -f /etc/pkgsync/musthave.ies || touch /etc/pkgsync/musthave.ies
test -f /etc/pkgsync/maynothave.ies || touch /etc/pkgsync/maynothave.ies
test -f /etc/pkgsync/mayhave.ies || touch /etc/pkgsync/mayhave.ies
test -f /etc/pkgsync/musthave.orphan || touch /etc/pkgsync/musthave.orphan

if [ "$IGNORE_MUSTHAVE" = "yes" ]; then
   MUSTHAVE=""
else
   MUSTHAVE="/etc/pkgsync/musthave"
fi

if [ "$IGNORE_MAYNOTHAVE" = "yes" ]; then
   MAYNOTHAVE=""
else
   MAYNOTHAVE="/etc/pkgsync/maynothave"
fi

if [ "$IGNORE_MAYHAVE" = "yes" ]; then
   MAYHAVE=""
else
   MAYHAVE="/etc/pkgsync/mayhave"
fi

# Merge files
sort -u -o /etc/pkgsync/musthave.all $MUSTHAVE /etc/pkgsync/musthave.ies $(find /etc/pkgsync/musthave.d -mindepth 1 -maxdepth 1 -type f 2>/dev/null)
sort -u -o /etc/pkgsync/maynothave.all $MAYNOTHAVE /etc/pkgsync/maynothave.ies $(find /etc/pkgsync/maynothave.d -mindepth 1 -maxdepth 1 -type f 2>/dev/null)
sort -u -o /etc/pkgsync/mayhave.all $MAYHAVE /etc/pkgsync/mayhave.ies $(find /etc/pkgsync/mayhave.d -mindepth 1 -maxdepth 1 -type f 2>/dev/null)

# Remove empty lines, blank spaces and tabs
sed -i 's/^ *//; s/ *$//; /^$/d; /^\s*$/d; s/^\t*//; s/\t*$//;' /etc/pkgsync/musthave.all
sed -i 's/^ *//; s/ *$//; /^$/d; /^\s*$/d; s/^\t*//; s/\t*$//;' /etc/pkgsync/mayhave.all
sed -i 's/^ *//; s/ *$//; /^$/d; /^\s*$/d; s/^\t*//; s/\t*$//;' /etc/pkgsync/maynothave.all

# Remove maynothave.all and musthave.orphan packages from musthave.all
comm -23 /etc/pkgsync/musthave.all /etc/pkgsync/musthave.orphan > /tmp/musthave.all
comm -23 /tmp/musthave.all /etc/pkgsync/maynothave.all > /etc/pkgsync/musthave.all

# Find out what parameters to give to aptitude.
installed=$( dpkg -l | grep '^ii' | cut -c5- | cut '-d ' -f1 )
musthave_install=$( getpkgs /etc/pkgsync/musthave.all | sort -u | sed "s/$/+/" )
maynothave_remove=$( getpkgs /etc/pkgsync/maynothave.all | sort -u | sed "s/$/-/" )
mayhave_marknonauto=$( getpkgs /etc/pkgsync/mayhave.all | sort -u | sed "s/$/\&m/" )
mustormayhave=$( ( getpkgs /etc/pkgsync/musthave.all ; getpkgs /etc/pkgsync/mayhave.all ) | sort -u )
rest_markauto=$( filter $installed $installed $mustormayhave | sed "s/$/\&M/" )

timeout $TIMEOUT_FOR_DPKG_OR_APT wait_for_apt_or_dpkg; run_aptitude full-upgrade '?upgradable' $musthave_install $maynothave_remove $mayhave_marknonauto $rest_markauto
run_aptitude autoclean

eliminar_kernels;eliminar_dependencias;eliminar_paquetes_huerfanos;apagar_equipo;reiniciar_equipo
